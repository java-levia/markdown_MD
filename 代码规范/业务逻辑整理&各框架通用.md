# 业务逻辑整理&各框架通用

* 对数据库的更新都使用了乐观锁（每次更改验证版本号）
* 在操作完之后验证了每次操作所影响的数据行数（不符合业务逻辑会抛出异常或者返回错误信息）
* 在做一些金额相关的操作时，每一类操作都有一个细节表记录每一次操作的类型、记录目前的状态、涉及金额、明细等关键信息。设计到金额或者积分的操作，数据库表中只做添加或修改，不做删除。
* 对操作后的金额必须进行非负验证，如果操作之后金额小于0（BigDecimal的比较采用compareTo方法），抛出运行时异常。

1. 关于订单流程

   * 和订单相关的有几张表？分别是什么关系？

   1. 订单的取消
      * 订单的定时取消可以开启独立的线程进行执行（效率更高）（Q：这个线程在什么时候调用）
        * 取消订单过程中，第一步首先释放库存，库存的处理在支付业务逻辑类中有定义一个处理类。库存定义了五种修改类型
          1. 增加占用库存，减少原始库存（用户下单但未付款，订单商品被划入占用）
          2. 减少占用库存，增加销售库存（用户付款，订单商品由占用更改为销售）
          3. 减少原始库存，增加销售库存（用户付款，订单商品直接由原始改为销售）
          4. 减少占用库存，增加原始库存（用户取消订单或者超时取消订单释放库存操作）

2. 关于金额或积分的相关操作
  1. 金额或积分的增减操作
    1. 在操作积分/金额（point）之前先保存一个元数据originPoint（用于保存到BMoneyDetails中存储为操作前金额）
    2. 判断是否为进账类型，是则执行添加金额增加方法（FunctionUtils中封装了BigDecimal的add和sub方法），否则执行sub方法
    3. 对进行过add/sub的金额point进行判断，如果point<0，返回一条错误信息，上级方法会对返回信息进行判断，如果返回信息不为空会当做运行时异常处理。如果point>0程序继续向下执行
    4. 修改账户余额（根据版本号乐观锁），对修改操作的返回值进行判断，如果返回值小于1说明修改操作失败，此时返回一条错误信息，上级方法会对返回信息进行判断，如果返回信息不为空会当做运行时异常处理。
    5. 创建一个BMoneyDetails对象设置相关属性并插入到数据库
    6. 对整个过程try...catch...，如果出现异常，catch中抛出一个自定义的ServiceException（运行时异常的子类）

  2. 金额的冻结/解冻/退款操作

     * 疑问：在解冻/退款操作中，都有一个相同的细节，在判断list中某个fDetails为空或者某个fDetails状态不为frozen_ing时，都会return；结束整个函数，（猜想：是不是因为一个订单id下的所有SFrozenMoneyDetails要么全部都为某一个状态（或者全部都存在），如果有缺失或者状态与业务逻辑不符，说明数据的完整性被破坏，但这样的状态为什么没有记录错误信息或者做出提示，而仅仅是结束方法）BIPBService.java   Line 1152

       ```java
       if(FunctionUtils.isEquals(StaticUtils.frozen_over, status)){
       				//然后 如果是解冻
       				//解冻就是把明细 状态修改 并且增加用户可用余额
       				//解冻一般都是在订单交易完成的时候执行的
       				//一笔订单可以有很多明细 每笔明细因为可能会触发到退款所以保存冻结记录的时候是每个明细都保存一下的
       				//所以这里解冻就是循环将整个订单都解冻咯
       				//因为会有 模式奖励 然后一个订单明细可能冻结了很多笔金额 这里一次性解冻完
       				//这里也好理解的
       				SFrozenMoneyDetailsExample detailExample=new SFrozenMoneyDetailsExample();
       				detailExample.createCriteria().andDetailidEqualTo(detailid);
       				List<SFrozenMoneyDetails> list=sFrozenMoneyDetailsMapper.selectByExample(detailExample);
       				Date now=new Date();
       				for(SFrozenMoneyDetails fDetails:list){
       					if(fDetails==null){
       						return ; //整个函数结束Levia
                               //这里为什么没有错误信息，list中有这条信息，执行到这里的时候发现为null，数据的完整性没有被破坏吗？
       					}
       					if(!FunctionUtils.isEquals(StaticUtils.frozen_ing, fDetails.getStatus())){
       						return ;//Levia：这里可以理解,从数据的完整性上来说，只要有一条已经解冻，说明所有数据都已解冻（真的是这样吗？）
       					}
       					//查询自己的金额信息
       					SSupplier ownMoney= sSupplierMapper.getBySupid(fDetails.getSupid());
       					BigDecimal ownFrozen=ownMoney.getFrozenmoney();
       					//然后减少自己的 已冻结金额
       					ownMoney.setFrozenmoney(FunctionUtils.sub(ownFrozen, fDetails.getMoney(), 2));
       					if(ownMoney.getFrozenmoney().compareTo(BigDecimal.ZERO)<0){
       						throw new ServiceException("FAIL");
       					}
       					int i=sSupplierMapper.updateMoneyLockVeriosn(ownMoney);
       					if(i<1) {
       						throw new ServiceException("FAIL");
       					}
       					fDetails.setEndtime(now);
       					fDetails.setStatus(status);
       					sFrozenMoneyDetailsMapper.updateByPrimaryKeySelective(fDetails);
       					//然后修改余额
       					String result=insertSupmoneyDetails(fDetails.getSupid(), fDetails.getTypeid(), StaticUtils.pay_in, paycode, fDetails.getMoney(), fDetails.getRemark());
       					if(result.length()>0){
       						throw new ServiceException(result);
       					}
       				}
       			}
       ```

     * 在退款业务逻辑中，还库存操作有疑问  HandlePayService.java   Line 2181

       ```java
       //如果订单是待发货 还库存（这里是不是有错误？不应该是comfire待支付?need_send待发货才对吧    Levia）
       			if(FunctionUtils.isEquals(order.getOrderstatus(), OrderstatusEnums.comfire.getId())) {
       				//锁库存 先减少库存然后 再判断
       				String qtyMsg=handleQtyReturn(details.getPdetailid(), details.getQty(), StaticUtils.sub_xs_add_ys, ext);
                       //这里的sub_xs_add_ys是减少销售库存增加原始库存
                       //销售库存应该是在确认支付之后才加上去的，confirm状态的应该只是占用库存。
       				if(!StringUtils.isEmpty(qtyMsg)) {
       					throw new ServiceException(qtyMsg);
       				}
       			}
       ```

       