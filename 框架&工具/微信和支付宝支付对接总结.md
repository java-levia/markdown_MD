微信和支付宝支付对接总结

1. 支付宝APP支付

   ```java
   //支付宝app下单
   try {
                   AlipayClient alipayClient = new DefaultAlipayClient(
                           "https://openapi.alipay.com/gateway.do", //请求地址
                           "2019053065350792",  //appId
                           Configue.infoAli.getAliprivatekey(),
                           "json",  //数据格式  一般是固定值JSON
                           "utf-8", //编码方式  一般是固定值utf-8
                           Configue.infoAli.getAlipublickey(), //这里需要的是支付宝公钥（注意与应用公钥区别开）
                           "RSA2" //这个是加密方式
                   ); //获得初始化的AlipayClient
                   AlipayTradeAppPayRequest request = new AlipayTradeAppPayRequest();//创建API对应的request
                   //异步url用于操作一些订单的后续流程
                   request.setNotifyUrl(haoHaiPay.getAliProperties().getAppPayAsynchroUrl());//在公共参数中设置回跳和通知地址
                   //构建订单参数
                   AlipayTradeAppPayModel model = new AlipayTradeAppPayModel();
                   model.setTotalAmount(rechargePayVO.getRealMoney().toString());
                   model.setSubject(MessageUtil.resultMessage("parameter_pay_subject"));
                   model.setProductCode("QUICK_MSECURITY_PAY");
                   model.setOutTradeNo(orderCode);  //设置外部订单号（平台自己生成的订单号）
                   request.setBizModel(model);//填充业务参数
                   String form = "";
                   try {
                       //这里和普通的接口调用不同，使用的是sdkExecute
                       AlipayTradeAppPayResponse response = alipayClient.sdkExecute(request);
                       //生成的是一个orderString 简单包装后直接发送给客户端
                       String keyInfo = response.getBody();
                       Map<String, String> map = new HashMap<>();
                       map.put("info", keyInfo);
                       return ResultResponse.getSuccess(MessageUtil.resultMessage("api_get_success"), map);
                   } catch (AlipayApiException e) {
                       e.printStackTrace();
                   }
               }catch (Exception ex){
                   logger.info("支付失败{}", ex);
                   throw new RRException(MessageUtil.resultMessage("api_pay_fail"));
               }
   ```

   ```java
   //支付宝异步回调
    @Transactional(rollbackFor = Exception.class)
       public void aliAsynchro(HttpServletRequest request, HttpServletResponse response) {
           Map<String, String> paramsMap = AlipayUtils.getReturnMap(request); //将异步通知中收到的所有参数都存放到map中
           boolean signVerified = false; //调用SDK验证签名
           //获取订单号
           logger.info("进入支付宝支付异步回调(app充值回调)获取结果集MAP"+paramsMap);
           //获取支付返回结果
           String trade_status=paramsMap.get("trade_status");
           //本系统的订单单号
           String orderCode=paramsMap.get("out_trade_no");
           //商户appid
           String appid = paramsMap.get("app_id");
           //付款方实际支付的金额
           BigDecimal buyerPayAmount = new BigDecimal(paramsMap.get("buyer_pay_amount"));
           //查询订单
           QueryWrapper qw = new QueryWrapper<>();
           qw.eq("ordercode", orderCode);
           CPayInfoEntity payInfo = cPayInfoMapper.selectOne(qw);
           if(EmptyUtil.isEmpty(payInfo)){
               throw new RRException("支付信息不存在");
           }
           //这个逻辑里面只处理订单状态更改逻辑和商家余额添加的逻辑，支付结果的通知通过订单结果的查询接口完成
           try {
               //注意这里使用的是应用公钥而不是支付宝公钥
               signVerified = AlipaySignature.rsaCheckV1(paramsMap, Configue.infoAli.getPartneraccount(), "utf-8", "RSA2");
               
               if(!signVerified){
                   logger.info("支付宝异步回调验签失败");
               }
           } catch (AlipayApiException e) {
               logger.info("支付宝异步回调验签异常"+e);
               throw new RRException("支付宝异步回调验签异常");
           }
           if(signVerified){
               logger.info("支付宝验签成功");
               // 这里进行一些业务方面的校验  收款金额/外部订单号/appid
               if(buyerPayAmount.compareTo(payInfo.getMoney())!=0
                       ||(!StringUtils.equals(Configue.infoAli.getPartner(), appid))){
                   try {
                       response.getWriter().write("failure");
                   } catch (IOException e) {
                       e.printStackTrace();
                   }
               }
               if(trade_status.equals("TRADE_FINISHED") || trade_status.equals("TRADE_SUCCESS")){
                   //支付宝生成的交易单号
                   String payCode=paramsMap.get("trade_no");
   
                   //这里开始处理本平台的业务逻辑（更改订单状态/商家钱包添加金额）
                   this.handleRechargeService(orderCode, payCode);
               }
           }
           try {
               response.getWriter().write("success");
           } catch (IOException e) {
               e.printStackTrace();
           }
       }
   
   
   
   package com.sx.utils.pay_util;
   
   import java.net.URLEncoder;
   import java.text.SimpleDateFormat;
   import java.util.HashMap;
   import java.util.Iterator;
   import java.util.Map;
   
   import javax.servlet.http.HttpServletRequest;
   
   /**
    * 支付宝支付工具类
    * @author Arno
    *
    */
   public class AlipayUtils {
   	
   	private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
   	
   	public static Map<String, String> getReturnMap(HttpServletRequest request){
   		//获取支付宝POST过来反馈信息
   		Map<String,String> params = new HashMap<String,String>();
   		Map requestParams = request.getParameterMap();
   		for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) {
   			String name = (String) iter.next();
   			String[] values = (String[]) requestParams.get(name);
   			String valueStr = "";
   			for (int i = 0; i < values.length; i++) {
   				valueStr = (i == values.length - 1) ? valueStr + values[i]
   						: valueStr + values[i] + ",";
   			}
   			//乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化
   			//valueStr = new String(valueStr.getBytes("ISO-8859-1"), "utf-8");
   			params.put(name, valueStr);
   		}
   		return params;
   	}
   	
   	
   }
   
   ```

2. 微信App支付

   ```java
   /**
        * 微信app支付
        * @param orderCode
        * @param order_price
        * @param NoticeURL 微信异步回调地址
        * @return
        * 封装请求参数
        */
       public static Map getWxPayApp(HttpServletRequest request,
                                     String appId, String body, String appmchid, String keyVal, String orderCode, BigDecimal order_price, String NoticeURL){
           WxPrePayEntity wxPrePayEntity= new WxPrePayEntity();
           int time=(int) (System.currentTimeMillis()/1000); //生成时间戳
           SortedMap<Object,Object> twiceMap = new TreeMap<Object,Object>();
           try {
               SortedMap<Object,Object> paramMap = new TreeMap<Object,Object>();
               String noncestr = TenpayUtil.CreateNoncestr();
               paramMap.put("appid",appId); //appid
               paramMap.put("body", body);         //描述
               paramMap.put("mch_id", appmchid); //商户号
               paramMap.put("nonce_str", noncestr);  //随机数
               paramMap.put("notify_url", NoticeURL); //支付成功后，回调地址
               paramMap.put("out_trade_no", orderCode); //商户 后台的贸易单号
               paramMap.put("product_id", orderCode); // 商户根据自己业务传递的参数 必填
               paramMap.put("spbill_create_ip", IPUtils.getRemoteHost(request)); //本机的Ip
               paramMap.put("total_fee", order_price.multiply(BigDecimal.valueOf(100)).intValue()+""); //金额必须为整数  单位为分，切必须是int类型转字符串（不能是小数，会验签失败）
               paramMap.put("trade_type", "APP"); //交易类型
               //根据微信签名规则，生成签名
               String sign =TenpayUtil.createSign("UTF-8", paramMap, keyVal);
               logger.info("微信app支付第一步签名sign"+sign);
               String xmlData=TenpayUtil.getRequestXml(paramMap,sign);
               String resdata= WeixinUtil.Unifiedorder(xmlData);
               logger.info("微信app支付验签"+resdata);
               Document dd =  DocumentHelper.parseText(resdata);
               if (dd != null) {
                   Element root = dd.getRootElement();
                   if (root == null) {
                       return null;
                   }
                   Element return_code=root.element("return_code");
                   String code=return_code.getText();
                   if(StringUtils.isBlank(code) || !"SUCCESS".equals(code.toUpperCase())) {
                       throw new ServiceException("签名失败");
                   }
                   Element trade_type = root.element("trade_type");
                   Element prepayId = root.element("prepay_id"); //获取预支付id
                   Element nonceStr = root.element("nonce_str");
                   String tradeType = trade_type.getText(); 
                   String preId = prepayId.getText();
                   twiceMap.put("appid", appId);
                   twiceMap.put("noncestr",nonceStr.getText());
                   twiceMap.put("package", "Sign=WXPay");
                   twiceMap.put("partnerid",appmchid);
                   twiceMap.put("prepayid", preId);
                   twiceMap.put("timestamp",time);
                   String twiceSign=TenpayUtil.createSign("UTF-8", twiceMap,keyVal);  //返回给客户端的sign参数必须是二次签名后的参数，否则客户端会无法调起微信支付页，但是报错也不明确（微信就是这么操蛋）
                   twiceMap.put("sign", twiceSign);
               }
           } catch (Exception e) {
               throw new RRException("签名失败", e);
           }
           return twiceMap;
       }
   }
   ```

   微信支付回调

   ```java
   /**
        * 微信异步回调
        * @param request
        * @param response
        */
       @Override
       @Transactional(rollbackFor = Exception.class)
       public void wxAsynchro(HttpServletRequest request, HttpServletResponse response) {
           //获取微信回调中返回到参数，并根据返回的参数确定支付状态进行业务处理
           Map<String, String> map= WeixinUtil.xmlToMap(request);
           logger.info("微信APP支付异步回调接收MAP"+map);
           //获取支付返回结果
           String return_code=map.get("return_code");
           //如果是支付成功
           if("SUCCESS".equals(return_code.toUpperCase())){
               //本系统的交易单号
               String paycode=map.get("out_trade_no");
               //微信生成的交易单号
               String transaction_id=map.get("transaction_id");
               //支付成功 回调
               try {
                   handleRechargeService(paycode, transaction_id);
               } catch (Exception e) {
                   logger.info("打印微信APP异步回调异常"+e.getMessage());
               }
               //修改支付记录为了对账使用
           }
           //回调之后 发送消息给微信通知已经接收到结果
           try {
               response.getWriter().write(return_code);
           } catch (IOException e) {
               e.printStackTrace();
           }
       }
   ```

   

   微信支付工具类

   ```java
   package com.sx.utils.pay_util;
   
   import com.sx.utils.Encode;
   
   import java.io.BufferedReader;
   import java.io.IOException;
   import java.io.InputStreamReader;
   import java.net.HttpURLConnection;
   import java.text.SimpleDateFormat;
   import java.util.Date;
   import java.util.Iterator;
   import java.util.Map;
   import java.util.Random;
   import java.util.Set;
   import java.util.SortedMap;
   
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   
   
   
   public class TenpayUtil {
   	
   	private static Object Server;
   	/**
   	 * 把对象转换成字符串
   	 * @param obj
   	 * @return String 转换成字符串,若对象为null,则返回空字符串.
   	 */
   	public static String toString(Object obj) {
   		if(obj == null)
   			return "";
   		
   		return obj.toString();
   	}
   	
   	/**
   	 * 把对象转换为int数值.
   	 * 
   	 * @param obj
   	 *            包含数字的对象.
   	 * @return int 转换后的数值,对不能转换的对象返回0。
   	 */
   	public static int toInt(Object obj) {
   		int a = 0;
   		try {
   			if (obj != null)
   				a = Integer.parseInt(obj.toString());
   		} catch (Exception e) {
   
   		}
   		return a;
   	}
   	
   	/**
   	 * 获取当前时间 yyyyMMddHHmmss
   	 * @return String
   	 */ 
   	public static String getCurrTime() {
   		Date now = new Date();
   		SimpleDateFormat outFormat = new SimpleDateFormat("yyyyMMddHHmmss");
   		String s = outFormat.format(now);
   		return s;
   	}
   	
   	/**
   	 * 获取当前日期 yyyyMMdd
   	 * @param date
   	 * @return String
   	 */
   	public static String formatDate(Date date) {
   		SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMdd");
   		String strDate = formatter.format(date);
   		return strDate;
   	}
   	
   	/**
   	 * 取出一个指定长度大小的随机正整数.
   	 * 
   	 * @param length
   	 *            int 设定所取出随机数的长度。length小于11
   	 * @return int 返回生成的随机数。
   	 */
   	public static int buildRandom(int length) {
   		int num = 1;
   		double random = Math.random();
   		if (random < 0.1) {
   			random = random + 0.1;
   		}
   		for (int i = 0; i < length; i++) {
   			num = num * 10;
   		}
   		return (int) ((random * num));
   	}
   	
   	/**
   	 * 获取编码字符集
   	 * @param request
   	 * @param response
   	 * @return String
   	 */
   
   	public static String getCharacterEncoding(HttpServletRequest request,
   			HttpServletResponse response) {
   		
   		if(null == request || null == response) {
   			return "gbk";
   		}
   		
   		String enc = request.getCharacterEncoding();
   		if(null == enc || "".equals(enc)) {
   			enc = response.getCharacterEncoding();
   		}
   		
   		if(null == enc || "".equals(enc)) {
   			enc = "gbk";
   		}
   		
   		return enc;
   	}
   	
   	public  static String URLencode(String content){
   		
   		String URLencode;
   		
   		URLencode= replace(Server.equals(content), "+", "%20");
   		
   		return URLencode;
   	}
   	private static String replace(boolean equals, String string, String string2) {
   		
   		return null;
   	}
   
   	/**
   	 * 获取unix时间，从1970-01-01 00:00:00开始的秒数
   	 * @param date
   	 * @return long
   	 */
   	public static long getUnixTime(Date date) {
   		if( null == date ) {
   			return 0;
   		}
   		
   		return date.getTime()/1000;
   	}
   	
   	 public static String QRfromGoogle(String chl)
   	    {
   	        int widhtHeight = 300;
   	        String EC_level = "L";
   	        int margin = 0;
   	        String QRfromGoogle;
   	        chl = URLencode(chl);
   	        
   	        QRfromGoogle = "http://chart.apis.google.com/chart?chs=" + widhtHeight + "x" + widhtHeight + "&cht=qr&chld=" + EC_level + "|" + margin + "&chl=" + chl;
   	       
   	        return QRfromGoogle;
   	    }
   
   	/**
   	 * 时间转换成字符串
   	 * @param date 时间
   	 * @param formatType 格式化类型
   	 * @return String
   	 */
   	public static String date2String(Date date, String formatType) {
   		SimpleDateFormat sdf = new SimpleDateFormat(formatType);
   		return sdf.format(date);
   	}
   	public static String getOut(HttpURLConnection conn) throws IOException{
   
           if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {
   
               return null;
   
           }
   
           // 获取响应内容体
   
           BufferedReader in = new BufferedReader(new InputStreamReader(
   
                   conn.getInputStream(), "UTF-8"));
   
           String line = "";
   
           StringBuffer strBuf = new StringBuffer();
   
           while ((line = in.readLine()) != null) {
   
               strBuf.append(line).append("\n");
   
           }
   
           in.close();
   
           return  strBuf.toString().trim();
   	}
   	public static String getTradeNo(){
   		String currTime = getCurrTime();
   		//8位日期
   		String strTime = currTime.substring(8, currTime.length());
   		//四位随机数
   		String strRandom = buildRandom(4) + "";
   		//10位序列号,可以自行调整。
   		String strReq = strTime + strRandom;
   		return strReq;
   	}
   	public static String getRequestXml(SortedMap<Object,Object> parameters,String sign){
   		StringBuffer sb = new StringBuffer();
   		sb.append("<xml>");
   		Set es = parameters.entrySet();
   		Iterator it = es.iterator();
   		while(it.hasNext()) {
   			Map.Entry entry = (Map.Entry)it.next();
   			String k = (String)entry.getKey();
   			String v = (String)entry.getValue();
   			if ("attach".equalsIgnoreCase(k)||"body".equalsIgnoreCase(k)||"sign".equalsIgnoreCase(k)) {
   				sb.append("<"+k+">"+"<![CDATA["+v+"]]></"+k+">");
   			}else {
   				sb.append("<"+k+">"+"<![CDATA["+v+"]]></"+k+">");
   			}
   			//sb.append("<"+k+">"+v+"</"+k+">");
   		}
   		sb.append("<sign>"+"<![CDATA["+sign+"]]></sign>");
   		sb.append("</xml>");
   		return sb.toString();
   	}
   	
   	public static String getRequestXml_twice(SortedMap<Object,Object> parameters,String sign){
   		StringBuffer sb = new StringBuffer();
   		sb.append("<xml>");
   		Set es = parameters.entrySet();
   		Iterator it = es.iterator();
   		while(it.hasNext()) {
   			Map.Entry entry = (Map.Entry)it.next();
   			String k = (String)entry.getKey();
   			String v = (String)entry.getValue();
   			if ("attach".equalsIgnoreCase(k)||"body".equalsIgnoreCase(k)||"sign".equalsIgnoreCase(k)) {
   				sb.append("<"+k+">"+""+v+"</"+k+">");
   			}else {
   				sb.append("<"+k+">"+""+v+"</"+k+">");
   			}
   			//sb.append("<"+k+">"+v+"</"+k+">");
   		}
   		sb.append("<sign>"+""+sign+"</sign>");
   		sb.append("</xml>");
   		return sb.toString();
   	}
   	public static String createAttach(String characterEncoding,SortedMap<Object,Object> parameters,String key){
   		StringBuffer sb = new StringBuffer();
   		Set es = parameters.entrySet();
   		Iterator it = es.iterator();
   		while(it.hasNext()) {
   			Map.Entry entry = (Map.Entry)it.next();
   			String k = (String)entry.getKey();
   			Object v = entry.getValue();
   			if(null != v && !"".equals(v) 
   					&& !"sign".equals(k) && !"key".equals(k)) {
   				sb.append(k + "=" + v + "&");
   			}
   		}
   		sb.append("key=" + key);
   		String sign = Encode.MD5Encode(sb.toString(), characterEncoding).toLowerCase();
   		return sign;
   	}
   	public static String createSign(String characterEncoding,SortedMap<Object,Object> parameters,String key){
   		StringBuffer sb = new StringBuffer();
   		Set es = parameters.entrySet();
   		Iterator it = es.iterator();
   		while(it.hasNext()) {
   			Map.Entry entry = (Map.Entry)it.next();
   			String k = (String)entry.getKey();
   			Object v = entry.getValue();
   			if(null != v && !"".equals(v) 
   					&& !"sign".equals(k) && !"key".equals(k)) {
   				sb.append(k + "=" + v + "&");
   			}
   		}
   		sb.append("key=" +key);
   		String sign = Encode.MD5Encode(sb.toString(), characterEncoding).toUpperCase();
   		return sign;
   	}
   	public static String CreateNoncestr(int length) {
   		String chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
   		String res = "";
   		for (int i = 0; i < length; i++) {
   			Random rd = new Random();
   			res += chars.indexOf(rd.nextInt(chars.length() - 1));
   		}
   		return res;
   	}
   	public static String CreateNoncestr() {
   		String chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
   		String res = "";
   		for (int i = 0; i < 16; i++) {
   			Random rd = new Random();
   			res += chars.charAt(rd.nextInt(chars.length() - 1));
   		}
   		return res;
   	}
   }
   
   
   
   package com.sx.utils;
   
   import java.io.BufferedReader;
   import java.io.IOException;
   import java.io.InputStream;
   import java.io.InputStreamReader;
   import java.io.OutputStream;
   import java.net.ConnectException;
   import java.net.URL;
   import java.util.HashMap;
   import java.util.List;
   import java.util.Map;
   
   import javax.net.ssl.HttpsURLConnection;
   import javax.net.ssl.SSLContext;
   import javax.net.ssl.SSLSocketFactory;
   import javax.net.ssl.TrustManager;
   import javax.servlet.http.HttpServletRequest;
   
   import com.sx.utils.pay_util.MyX509TrustManager;
   import org.dom4j.Document;
   import org.dom4j.DocumentException;
   import org.dom4j.Element;
   import org.dom4j.io.SAXReader;
   
   /**
    * 公众平台通用接口工具类
    * @author Administrator
    *
    */
   public class WeixinUtil{
   	public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {
           try {
               // 创建SSLContext对象，并使用我们指定的信任管理器初始化
               TrustManager[] tm = { new MyX509TrustManager() };
               SSLContext sslContext = SSLContext.getInstance("SSL", "SunJSSE");
               sslContext.init(null, tm, new java.security.SecureRandom());
               // 从上述SSLContext对象中得到SSLSocketFactory对象
               SSLSocketFactory ssf = sslContext.getSocketFactory();
               URL url = new URL(requestUrl);
               HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
               conn.setSSLSocketFactory(ssf);
               conn.setDoOutput(true);
               conn.setDoInput(true);
               conn.setUseCaches(false);
               // 设置请求方式（GET/POST）
               conn.setRequestMethod(requestMethod);
               conn.setRequestProperty("Charsert", "UTF-8");
               conn.setRequestProperty("content-type", "application/x-www-form-urlencoded");
               // 当outputStr不为null时向输出流写数据
               if (null != outputStr) {
                   OutputStream outputStream = conn.getOutputStream();
                   // 注意编码格式
                   outputStream.write(outputStr.getBytes("UTF-8"));
                   outputStream.close();
               }
               // 从输入流读取返回内容
               InputStream inputStream = conn.getInputStream();
               InputStreamReader inputStreamReader = new InputStreamReader(inputStream, "utf-8");
               BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
               String str = null;
               StringBuffer buffer = new StringBuffer();
               while ((str = bufferedReader.readLine()) != null) {
                   buffer.append(str);
               }
               // 释放资源
               bufferedReader.close();
               inputStreamReader.close();
               inputStream.close();
               inputStream = null;
               conn.disconnect();
               return buffer.toString();
           } catch (ConnectException ce) {
               System.out.println("连接超时：{}"+ce);
           } catch (Exception e) {
           	System.out.println("https请求异常：{}"+ e);
           }
           return null;
       }
   	public static String Unifiedorder(String requestXML){
   	    //https://api.mch.weixin.qq.com/pay/unifiedorder
   		String requestUrl="https://api.mch.weixin.qq.com/pay/unifiedorder";
   		String result =httpsRequest(requestUrl, "POST", requestXML);
   		return result;
   	}
   	
   	public static String Unifiedorder_query(String requestXML){
   		String requestUrl="https://api.mch.weixin.qq.com/pay/orderquery";
   		String result =httpsRequest(requestUrl, "POST", requestXML);
   		return result;
   	}
   	
   	public static String Unifiedorder_shouying(String requestXML){
   		String requestUrl="https://api.mch.weixin.qq.com/pay/micropay";
   		String result =httpsRequest(requestUrl, "POST", requestXML);
   		return result;
   	}
   	
   	public static String Unifiedorder_refund(String requestXML){
   		String requestUrl="https://api.mch.weixin.qq.com/secapi/pay/refund";
   		String result =httpsRequest(requestUrl, "POST", requestXML);
   		return result;
   	}
   	
   	/**
        * 将xml转化为Map集合
        * 
        * @param request
        * @return
        */
       public static Map<String, String> xmlToMap(HttpServletRequest request) {
           Map<String, String> map = new HashMap<String, String>();
           SAXReader reader = new SAXReader();
           InputStream ins = null;
           try {
               ins = request.getInputStream();
           } catch (IOException e1) {
               e1.printStackTrace();
           }
           Document doc = null;
           try {
               doc = reader.read(ins);
           } catch (DocumentException e1) {
               e1.printStackTrace();
           }
           Element root = doc.getRootElement();
           @SuppressWarnings("unchecked")
           List<Element> list = root.elements();
           for (Element e : list) {
               map.put(e.getName(), e.getText());
           }
           try {
               ins.close();
           } catch (IOException e1) {
               e1.printStackTrace();
           }
           return map;
       }
   }
   
   ```

3. 支付宝H5支付

   ```java
   //与App支付的差别并不大 只是一些参数封装和返回值不一样
   
   try {
                   AlipayClient alipayClient = new DefaultAlipayClient(
                           "https://openapi.alipay.com/gateway.do",
                           "2019053065350792",
                           Configue.infoAli.getAliprivatekey(),
                           "json",
                           "utf-8",
                           Configue.infoAli.getAlipublickey(),
                           "RSA2"); //获得初始化的AlipayClient
                   AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
                   //同步的url用于支付完成之后展示一些订单信息
                   alipayRequest.setReturnUrl(haoHaiPay.getAliProperties().getAliPayReturnUrl());
                   //异步url用于操作一些订单的后续流程
                   alipayRequest.setNotifyUrl(Configue.infoDomain.getAppurl()+haoHaiPay.getAliProperties().getAliPayAsynchroUrl());//在公共参数中设置回跳和通知地址
                   //构建订单参数
                   AlipayTradeWapPayModel model = new AlipayTradeWapPayModel();
                   model.setOutTradeNo(order.getOrderCode());
                   model.setTotalAmount(order.getRealMoney().toString());
                   model.setSubject(MessageUtil.resultMessage("parameter_pay_subject"));
                   model.setProductCode("QUICK_WAP_WAY");
                   alipayRequest.setBizModel(model);//填充业务参数
                   String formStr = "";
                   try {
                       formStr = alipayClient.pageExecute(alipayRequest).getBody(); //调用SDK生成表单（生成一个form表单，并输出到页面并操作dom进行提交）
                   }catch (Exception ex){
                       logger.info("支付页面调用失败{}", ex);
                       throw new RRException(MessageUtil.resultMessage("api_pay_fail"));
                   }
                   /*response.setContentType("text/html;charset=utf-8");
                   response.getWriter().write(formStr);//直接将完整的表单html输出到页面
                   response.getWriter().flush();
                   response.getWriter().close();*/
                   return ResultResponse.getSuccess(formStr, 1);
               }catch (Exception ex){
                   logger.info("支付页输出失败{}", ex);
                   throw new RRException(MessageUtil.resultMessage("api_pay_fail"));
               }
   ```

   