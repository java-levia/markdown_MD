#Spring框架#
##SpringIOC##
1. SpringIOC阐述
	* SpringIOC是一种通过描述(在Java中可以是XML或者注解)并通过第三方去产生或者获取特定对象的方式。而在Spring中实现控制反转（Inversion of Control）的是IoC容器，其实现方法是依赖注入（Dependency Injection, DI）。
		
	* 部分开发者对Ioc和DI的概念有些混淆，认为二者是对等的，其实不是。Ioc其实有两种方式，一种是依赖注入（DI），另一种是依赖查找（Dependency Lookup, DL）。前者是当前软件实体被动接受其依赖的其他组件被IoC容器注入，而后者是当前的软件实体主动去某个服务注册地查找器依赖的那些服务。

2. SpringIOC容器
	* SpringIOC容器的设计主要是基于BeanFactory和ApplicationContext两个接口，其中ApplicationContext是BeanFactory的子接口之一，BeanFactory是Spring IOC定义的最底层接口，ApplicationContext是其高级接口之一，并且对BeanFactory功能做了许多有用的扩展。

	* 我们通常说的Spring IoC实际上是指Spring框架提供的Ioc容器实现。
	
	 1. Spring的Ioc容器中发生的事情其实也很简单，总结下来分为两个阶段：
			- 收集和注册
			* 第一个阶段可以认为是构建和收集Bean定义的阶段，在这个阶段中我们可以通过XML或者Java代码的方式定义一些Bean，然后通过手动组装或者让容器基于某些机制自动扫描的形式，将这些bean定义收集到Ioc容器中。

			*Bean的定义可以分为三步：
				1 Resource定位，这步时SpringIoc容器根据开发者的配置，进行资源的定位。在开发中常用的方式是XML或者注解的方式。
				2 BeanDefinition的载入，这个时候只是将BeanDefiniton的信息保存到Spring IoC容器中，此时不会创建Bean的实例
				3 BeanDefinition的注册，这个过程就是将BeanDefiniton的信息发布到Spring IoC容器中，，此时仍旧不会创建Bean的实例
			这三步之后Bean就在Spring Ioc容器中被定义了，但是没有初始化，更没有完成依赖注入，也就是还没有注入器配置的资源给Bean，那么它还不能使用。

		- 分析和组装
			*当阶段一的工作完成后，可以认为IoC容器中充斥着一个个独立的Bean，他们之间没有任何关系。但实际上，他们之间是有依赖关系的，所以，Ioc容器在第二阶段要做的就是分析Ioc容器中的Bean，然后根据他们之间的关系先后组装他们。如果Ioc容器发现某个Bean依赖另一个Bean，它就会将这另一个Bean注入给依赖它的那个Bean，直到所有Bean的依赖都注入完成，这个Ioc容器的工作即算完成。

3. 依赖注入的三种方式
	


4. spring数据库事务
  1. 数据库事务的ACID特性
    1. 原子性：事务就是一系列的操作，要么这些操作全部执行，要么全部不执行。如果在执行操作的时候发生异常，则对之前执行过的所有操作进行回滚。
    	- 在MYSQL中，这个回滚是通过回滚日志（Undo Log）实现的，简单地说，回滚日志就是记录了你所有操作的逆操作，在需要回滚时就把这个事务的回滚日志里的操作全部执行一次。

    2. 隔离性：事务的隔离性会跟并发等概念的联系非常密切，因为它主要就是为了保证并行事务处理能够达到互不干扰的效果。
    	- 在事务的一致性中讨论过事务在并发情况下执行时，可能发生的一系列问题：虽然单个事务执行并没有错误，但是它执行可能会牵连到其他事务的执行，最终导致数据库的整体一致性出现偏差。
    	
    	- 数据库事务中为了解决隔离性问题，定义了四种隔离级别。大部分数据库中使用读已提交作为默认的隔离级别，这是出于性能和一致性的平衡。mysql中默认采用可重复度。
    		1. 读未提交：使用查询语句不会加锁，可能会读到未提交的行，产生脏读。
    		2. 读已提交：只对已存在的记录加记录锁，而不会在记录之间增加间隙锁，所以允许新的纪录被插入到被锁定的纪录附近，在多次使用查询语句时 ，可能会得到不同的结果（不可重复读）。
    		3. 可重复读：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读。
    				- 幻读 : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
    		4. 串行化：隐式地将全部地查询语句都加上了共享锁。
    	
    	- 隔离的实现
    		1. 锁
    			- 这个自然是最简单得，也是相当常用的并发控制机制了。
    			- 不过在一个事务中，是不可能将整个数据库都加锁的，而是只对要访问的数据加锁（具体的粒度有行、表），而这些资源锁也是理所当然地分为共享读锁和独占写锁。
    			- 读锁可以保证操作系统并发执行不受影响，写锁则保证了更新数据库时不会受到其他事务的干扰。

    		2. 时间戳
    			- 用时间戳实现隔离性，需要为纪录配置两个字段
    				* 读时间戳  用于保存所有访问该纪录的事务中的最大时间戳（最后读取时间）
    				* 写时间戳  用于保存将纪录改到当前值的事务的时间戳（最后修改时间）
    			- 这样的事务在并行执行时用的是**乐观锁**，先任由事务对数据进行修改，在写回去的时候再判断纪录的时间戳有没有修改，如果没有修改就写入，否则，就生成一个新的时间戳并再次尝试更新数据。

    		3. 多版本和快照隔离
    			- 通过维护多个版本的数据，数据库便可以允许事务并发执行，遇到互斥锁时，转而读取旧版本的数据快照。这样就能显著提升读取性能，这一手段被称为MVCC.

    	- 级联回滚
    		- 之前在讨论原子性问题时，讨论过级联回滚的问题。那是因为事务之间产生了依赖而导致的。因此我们将事务隔离之后就不会再产生需要级联回滚的场景了。
    		- 比如一个事务写入A数据，那么这时候是需要加独占锁的，因此其他的事务无法读取A，当事务A回滚时不用考虑对其他事务的影响，因为其他事务不可能读取到数据。
    		

    3. 一致性：一致性在数据库有两个意义，一个是ACID中的C，一个是CAP中的C。
    	1. ACID中的C：事务的一致性定义可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行前后都是合法的数据状态，不会违背任何数据的完整性，这就是一致的意思。
    	2. CAP中的C：CAP定理是分布式系统理论的基础。CAP告诉我们，对于一个分布式系统（或者由于网络隔离等原因产生的分区系统），它无法保证同时保证一致性、可用性和分区容忍性，二十必须要舍弃其中一个。（暂时不理解）
    		1. 对于分布式系统一般我们是不可能舍弃分区容忍性的（因为分区的情况是无法避免的），所以一般是根据业务，在一致性和可用性中二选一。
    		2. 这里说的一致性，具体在数据库上，就是分布式数据库中，每一个节点对于同一个数据必须有相同的拷贝（每个库里同一个数据内容必须是一致的）。

    4. 持久性：指事务一旦提交，那么数据一定会被写到数据库中并持久保存起来。另外，当事务被提交后就无法再回滚，如果想要撤销一个已经提交的事务，那就只能执行一个效果与其相反的事务，这也是持久性的一种体现。关于这点，MYSQL依旧是通过日志实现的。
  2. Spring事务的失效问题
    1. 在Spring进行数据库事务管理时，注解@Transactional的底层实现时SpringAOP技术，而SpringAop技术使用的是动态代理。这就意味着对于静态方法和非public方法，注解@Transactional是失效的。
    2. 自调用失效：所谓的自调用，就是一个类的一个方法去调用自身另外一个方法的过程。
  3. 传播行为
    1. 传播行为是指方法之间调用事务策略的问题。大多数情况下我们都希望事务能够同时成功或者同时失败，但有时候也有例外，这时候就需要利用传播行为控制事务的调用。
    2. 传播行为：
    	1. REQUIRED		当方法调用时，如果不存在当前事务，那么就创建事务，如果之前的方法已经存在事务，那么就沿用之前的事务。		这是Spring默认的传播行为。
    		. SUPPORTS		当方法调用时，如果存在当前事务，就沿用当前事务，如果不存在当前事务，也不启动事务。
    		. MANDATORY	方法必须在事务内运行		如果不存在当前事务，那么就抛出异常
    		. REQUIRES_NEW	无论是否存在当前事务，方法都会在新的事务中运行		也就是每次调用方法，事务管理器都会打开新的事务运行该方法。
    		. NOT_SUPPORTED	不支持事务，如果不存在当前事务也不会创建事务，如果存在当前事务，则挂起它，直到方法结束后才恢复当前事务。适用于那些不需要事务的SQL
    		. NEVER	不支持事务，只有在没有事务的环境中才能运行它		如果方法存在当前事务，则抛出异常
    		. NESTED	嵌套事务，也就是调用方法如果抛出异常只回滚自己内部执行的SQL,而不回滚主方法的SQL。
  4. 事务调用中的错误用法
    1. 错误使用Service：在同一个controller中两次调用同一个带有事务的service方法，要求两次调用处于同一个事务中。这时当第一次调用方法结束时，事务已经结束了，第二次调用方法其实开启的是新的事务，这时如果第一次方法调用成功而第二次方法调用失败了，会导致数据不一致的问题。
    2. 过长时间占用事务：在企业生产系统中，数据库资源是最宝贵的系统资源之一，使用了数据库事务之后，要及时释放数据库事务。换言之，我们应该尽可能地利用数据库事务资源去完成所需工作，但是在一些工作中需要使用到文件、对外连接等操作，这些操作会占用较长时间，针对这些，如果开发者不注意细节，往往会导致系统宕机问题。
    3. 错误捕捉异常：错误地使用try{}catch{}语句会导致事务中无法抛出异常，导致事务无法回滚。
  5. 关于spring中的父子容器问题
     1. 在spring的启动过程中，spring属于父容器，springMvc属于子容器
     2. 父容器无法获取子容器中的Bean，子容器可以获取所有父容器的Bean和自身的Bean，但是默认情况下，父容器的Bean是不和子容器共享的，如果需要在子容器中获取父容器的Bean得再配置文件中做相关配置。
