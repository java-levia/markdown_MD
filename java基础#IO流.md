#java基础#
##IO流##

1.异常 Throwable类

	1. 异常Throwable类是java语言中所有错误或者异常的超类，它有两个子类，Error和Exception。
	2. 严重问题：Error
		- Error用于指示合理的应用程序不应该试图捕获的严重问题。Error在程序中无法处理
	3. 普通问题：Exception
		- 编译期 问题：不是RuntimeException的异常，这类异常需要我们在代码中进行处理，否则无法通过编译。
		- 运行期问题：RuntimeException，出现这种问题说明我们的代码不合理，需要修改代码。

	4. 如果程序出现问题，我们没有进行处理，虚拟机会做出默认的处理。
		- 虚拟机的处理方式是将异常的名称、原因及出现的问题等信息输出在控制台。同时程序停止在出错的地方，无法继续向下运行

	5. 异常处理
		1. try...catch...finally
			- try里面的代码越少越好，因为try里的代码是需要走异常处理机制的，虚拟机是需要分配一些资源来管理try里的代码。
			- catch里面必须有内容，只有这样才能对catch所处理的问题暴露出来，否则就相当于隐藏了问题。
			- 在try...catch语句中，一旦try中出现问题，就会和catch里面的问题进行匹配，一旦匹配成功，就执行catch里面的处理，然后就结束了try...catch语句（这时候会出现在try中位于问题语句下方的语句无法执行到的问题） 
			- 在异常处理中，能明确的尽量明确，不要直接用Exception来处理（用Exception处理的时候，虚拟机会拿着出现的异常到Exception的子类中进行匹配，这样有点降低程序的效率）
			- 平级关系的异常谁前谁后无所谓，如果出现了子父关系，父类的异常必须在后，否则会报编译器异常
			- JDK7出现了一个新的异常处理方案  -> try{}catch(异常1 | 异常2 | ... e){}   ,但这种处理方式也有一个问题，就是括号里的多个异常必须是平级关系。
			- 在try里面发现问题后，jvm会帮我们生成一个异常对象，然后把这个对象抛出，和catch里面的类进行匹配。如果该对象是某个类型的，就会执行该catch里面的处理信息。
			- catch中使用e.printStackTrace()获取异常类名和异常信息，以及异常出现在程序中的文职。返回值void。把信息输出在控制台。
			- catch中使用printStackTrace(PrintStream s) 通常用该方法将异常信息保存在日志文件中，一边查阅定位异常。 

		2. Throws
			- 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。这种情况可以通过throws在方法上标识。
			- 在程序中，如果一个方法上抛出了编译时异常，方法的调用者必须对异常进行处理，如果方法抛出的是运行期异常，方法的调用者可以不对异常进行处理。

		3. throw
			- 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常抛出。
			- throw用于在方法内部抛出异常对象
			- throws往往表达的是一种抛出异常的可能性，而执行到throw则表示一定抛出了异常

		4. 三种异常处理方式的选择
			- 如果该功能内部可以将问题处理，用try，如果处理不了则用throws
		
		5. finally
			- 被finally控制的语句体一定会执行，但是如果在执行到finally之前jvm退出了，则finally不能执行了。
			- 用于释放资源，在io流操作或者数据库操作中经常会见到。
			- 如果catch里面有return语句，finally语句的代码会在return之前执行（严格来说并不是再return之前，而是在return执行到一半的时候）。而且，如果finally中的语句对return的结果有更改，最终return的还会是运行finally之前的那个结果，因为在执行finally之前return后面的对象已经被替换为了具体的值，而finally对值所做出的更改已经无法改变已经替换的返回值。（也就是说finally对值做出的更改是有效的，只是无法再通过return返回）（有点绕）

		
		6. 自定义异常
			- 自定义异常需要继承Exception或者RuntimeException
			- 自定义异常如果需要异常信息提示，需要在自定义异常中定义一个有参构造并使用super关键字调用父类的有参构造。（定义了有参构造的同时也必须定义一个无参构造）


		7. 异常的注意事项
			1. 子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。
			2. 如果父类抛出了多个异常，子类重写父类的方法时，只能抛出相同的异常或者异常的子集，子类不能抛出父类没有的异常。
			3. 如果被重写的父类方法没有异常抛出，那么子类绝对不可以抛出异常，如果子类方法内有异常发生，那么子类只能try，不能throws。